import requests
import time
from core.models import Kline, Indicator, Indicator, SymbolStrategy, TradeLog
from django.db.models import Min, Max, Sum, Avg, Count
from datetime import datetime, timezone
import pandas as pd
import threading
import numpy as np
import operator

OPERATORS = {
    "<": operator.lt,
    "<=": operator.le,
    ">": operator.gt,
    ">=": operator.ge,
    "==": operator.eq
}

loaded_symbols = {}
print(f"‚úÖ [DEBUG] loaded_symbols d√©fini dans utils : {loaded_symbols}")
loaded_symbols_lock = threading.Lock()#

BINANCE_BASE_URL = "https://api.binance.com/api/v3"
BINANCE_BASE_URL_klines = BINANCE_BASE_URL + "/klines"
BINANCE_BASE_URL_liste  =  BINANCE_BASE_URL +"/exchangeInfo"

INTERVAL_MAPPING = {
    "3m": 3,
    "5m": 5,
    "15m": 15,
    "1h": 60,
    "4h": 240,
    "1d": 1440
}

def get_loaded_symbols():
    global loaded_symbols
    return loaded_symbols

def get_all_usdt_pairs():
    """
    R√©cup√®re toutes les paires USDT disponibles sur Binance.
    """
    response = requests.get(BINANCE_BASE_URL_liste)
    if response.status_code == 200:
        data = response.json()
        symbols = [s["symbol"] for s in data["symbols"] if s["symbol"].endswith("USDT")]
        print(f"‚úÖ {len(symbols)} paires USDT trouv√©es.")
        return symbols
    else:
        print(f"‚ùå Erreur lors de la r√©cup√©ration des paires Binance: {response.status_code}")
        return []

def load_historical_klines():
    """
    Charge l'historique des Klines pour toutes les paires USDT.
    """
    from core.utils import get_historical_klines

    symbols = get_all_usdt_pairs()
    for symbol in symbols:
        print(f"üîÑ Chargement des Klines pour {symbol}...")
        get_historical_klines(symbol, "1m")

def get_historical_klines(symbol, interval, limit=5000):
    global loaded_symbols

    print(f"üîÑ Chargement de l'historique ({limit} Klines) pour {symbol}...")

    all_klines = []
    last_timestamp = None

    while len(all_klines) < limit:
        request_limit = min(1000, limit - len(all_klines))  # Ne pas d√©passer `limit`
        url = f"{BINANCE_BASE_URL}?symbol={symbol}&interval={interval}&limit={request_limit}"
        
        if last_timestamp:
            url += f"&endTime={last_timestamp}"  # Charger des Klines plus anciennes

        response = requests.get(url)
        if response.status_code != 200:
            print(f"‚ùå Erreur API Binance : {response.status_code} - {response.text}")
            break

        data = response.json()
        if not data:
            break  # Plus de donn√©es disponibles

        all_klines.extend(data)
        last_timestamp = data[0][0]  # Mettre √† jour `endTime` pour la prochaine requ√™te

    print(f"‚úÖ Total {len(all_klines)} Klines r√©cup√©r√©es pour {symbol}")

    # Enregistrer toutes les Klines en base
    klines_to_insert = [
        Kline(
            symbole=symbol,
            intervalle=interval,
            timestamp=k[0],
            open_price=float(k[1]),
            high_price=float(k[2]),
            low_price=float(k[3]),
            close_price=float(k[4]),
            volume=float(k[5])
        ) for k in all_klines
    ]

    Kline.objects.bulk_create(klines_to_insert, ignore_conflicts=True)
    loaded_symbols[symbol] = True
    
def aggregate_higher_timeframe_klines(symbole):
    print(f"üîÑ [DEBUG] Agr√©gation des Klines sup√©rieures pour {symbole}...")

    intervals = {"3m": 3, "5m": 5, "15m": 15, "1h": 60, "4h": 240, "1d": 1440}

    for interval, factor in intervals.items():
        print(f"  ‚û°Ô∏è Agr√©gation pour {interval} (n√©cessite {factor} bougies 1m)")

        # R√©cup√©rer la derni√®re bougie 1m en base
        last_kline_1m = Kline.objects.filter(symbole=symbole, intervalle="1m").order_by("-timestamp").first()
        if not last_kline_1m:
            print(f"‚ö†Ô∏è Aucune bougie 1m disponible pour {symbole}, impossible d'agr√©ger {interval}")
            continue

        last_timestamp = last_kline_1m.timestamp

        # Trouver le timestamp de d√©but du nouvel intervalle
        aligned_timestamp = last_timestamp - (last_timestamp % (factor * 60 * 1000))

        # R√©cup√©rer toutes les bougies 1m qui appartiennent √† cet intervalle
        klines_1m = list(Kline.objects.filter(
            symbole=symbole,
            intervalle="1m",
            timestamp__gte=aligned_timestamp
        ).order_by("timestamp"))

        print(f"  üîç {len(klines_1m)} bougies 1m trouv√©es pour {interval}")

        if len(klines_1m) < factor:
            print(f"‚ö†Ô∏è Pas assez de bougies 1m align√©es pour g√©n√©rer {interval} ({len(klines_1m)} trouv√©es)")
            continue

        open_price = klines_1m[0].open_price
        close_price = klines_1m[-1].close_price
        high_price = max(k.high_price for k in klines_1m)
        low_price = min(k.low_price for k in klines_1m)
        volume = sum(k.volume for k in klines_1m)

        # Ins√©rer ou mettre √† jour la Kline agr√©g√©e
        kline, created = Kline.objects.update_or_create(
            symbole=symbole,
            intervalle=interval,
            timestamp=aligned_timestamp,
            defaults={
                "open_price": open_price,
                "high_price": high_price,
                "low_price": low_price,
                "close_price": close_price,
                "volume": volume,
            }
        )

        if created:
            print(f"‚úÖ Nouvelle Kline {interval} cr√©√©e pour {symbole} √† {aligned_timestamp}")
        else:
            print(f"‚ôªÔ∏è Kline {interval} mise √† jour pour {symbole} √† {aligned_timestamp}")

def calculate_indicators(symbol, interval):
    """
    Calcule le MACD, RSI et les bandes de Bollinger pour un symbole donn√© et un intervalle.
    """
    print(f"üìä D√©but du calcul des indicateurs pour {symbol} ({interval})")
    klines = list(Kline.objects.filter(symbole=symbol, intervalle=interval).order_by("timestamp").values())

    if len(klines) < 50:  # Assurez-vous d'avoir assez de donn√©es
        return None

    df = pd.DataFrame(klines)
    df["close_price"] = df["close_price"].astype(float)

    # ‚úÖ Calcul du MACD
    short_ema = df["close_price"].ewm(span=12, adjust=False).mean()
    long_ema = df["close_price"].ewm(span=26, adjust=False).mean()
    df["macd"] = short_ema - long_ema
    df["macd_signal"] = df["macd"].ewm(span=9, adjust=False).mean()

    # ‚úÖ Calcul du RSI
    delta = df["close_price"].diff()
    gain = (delta.where(delta > 0, 0)).rolling(14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
    rs = gain / loss
    df["rsi"] = 100 - (100 / (1 + rs))

    # ‚úÖ Calcul du StochRSI
    min_rsi = df["rsi"].rolling(window=14).min()
    max_rsi = df["rsi"].rolling(window=14).max()
    df["stoch_rsi"] = (df["rsi"] - min_rsi) / (max_rsi - min_rsi)

    # ‚úÖ Calcul des Bollinger Bands
    df["bollinger_middle"] = df["close_price"].rolling(window=20).mean()  # ‚úÖ Ajout de la bande m√©diane
    rolling_std = df["close_price"].rolling(window=20).std()
    df["bollinger_upper"] = df["bollinger_middle"] + (rolling_std * 2)
    df["bollinger_lower"] = df["bollinger_middle"] - (rolling_std * 2)    

    latest = df.iloc[-1]  # On prend la derni√®re ligne
    print(f"üìå Derniers indicateurs pour {symbol} ({interval}):")
    print(f"  MACD: {latest['macd']:.2f}, MACD Signal: {latest['macd_signal']:.2f}")
    print(f"  RSI: {latest['rsi']:.2f}")
    print(f"  Bollinger: {latest['bollinger_lower']:.2f} - {latest['bollinger_upper']:.2f}")

    # ‚úÖ Enregistrement en base
    Indicator.objects.update_or_create(
        symbole=symbol,
        intervalle=interval,
        timestamp=int(latest["timestamp"]),
        defaults={
            "macd": latest["macd"],
            "macd_signal": latest["macd_signal"],
            "rsi": latest["rsi"],
            "stoch_rsi": latest["stoch_rsi"],
            "bollinger_upper": latest["bollinger_upper"],
            "bollinger_middle": latest["bollinger_middle"],
            "bollinger_lower": latest["bollinger_lower"],
        }
    )

    return latest

def calculate_rsi(symbol, interval, period=6):
    """
    Calcule le RSI pour une paire et un intervalle donn√©.
    """
    klines = Kline.objects.filter(symbole=symbol, intervalle=interval).order_by("-timestamp")[:period + 1]
    
    if len(klines) < period + 1:
        return None  # Pas assez de donn√©es

    df = pd.DataFrame(list(klines.values("close_price")))
    df["delta"] = df["close_price"].diff()

    gain = (df["delta"].where(df["delta"] > 0, 0)).rolling(window=period).mean()
    loss = (-df["delta"].where(df["delta"] < 0, 0)).rolling(window=period).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return round(rsi.iloc[-1], 2)  # Retourne le dernier RSI calcul√©

def calculate_macd(symbol, interval, short_window=12, long_window=26, signal_window=9):
    """
    Calcule le MACD pour une paire et un intervalle donn√©.
    """
    from core.models import Kline

    klines = Kline.objects.filter(symbole=symbol, intervalle=interval).order_by("timestamp")
    
    if len(klines) < long_window:
        return None  # Pas assez de donn√©es

    df = pd.DataFrame(list(klines.values("timestamp", "close_price")))
    
    df["EMA_12"] = df["close_price"].ewm(span=short_window, adjust=False).mean()
    df["EMA_26"] = df["close_price"].ewm(span=long_window, adjust=False).mean()
    df["MACD"] = df["EMA_12"] - df["EMA_26"]
    df["Signal_Line"] = df["MACD"].ewm(span=signal_window, adjust=False).mean()

    return df.iloc[-1]["MACD"], df.iloc[-1]["Signal_Line"]

def calculate_bollinger_bands(symbol, interval, window=20):
    """
    Calcule les bandes de Bollinger pour une paire et un intervalle donn√©.
    """
    from core.models import Kline

    klines = Kline.objects.filter(symbole=symbol, intervalle=interval).order_by("timestamp")

    if len(klines) < window:
        return None  # Pas assez de donn√©es

    df = pd.DataFrame(list(klines.values("timestamp", "close_price")))
    
    df["SMA"] = df["close_price"].rolling(window=window).mean()
    df["STD"] = df["close_price"].rolling(window=window).std()
    
    df["Upper_Band"] = df["SMA"] + (df["STD"] * 2)
    df["Lower_Band"] = df["SMA"] - (df["STD"] * 2)

    return df.iloc[-1]["Upper_Band"], df.iloc[-1]["Lower_Band"]

def parse_condition(condition):
    """
    Transforme une condition sous forme de string ("<5") en une fonction et une valeur.
    """
    for op in OPERATORS:
        if condition.startswith(op):
            value = float(condition[len(op):])
            return OPERATORS[op], value
    return None, None

def check_strategy_conditions(symbole, interval, conditions):
    """
    V√©rifie si une liste de conditions est remplie pour une monnaie donn√©e, 
    m√™me si elles concernent plusieurs intervalles.
    """
    # R√©cup√©ration initiale des indicateurs pour l'intervalle en cours
    latest_indicator = Indicator.objects.filter(symbole=symbole, intervalle=interval).order_by("-timestamp").first()
    
    if not latest_indicator:
        return False  # Pas assez de donn√©es pour l'intervalle actuel

    for indicator_key, condition in conditions.items():
        # Extraire l'indicateur et l'intervalle depuis la cl√© (ex: "stoch_rsi_3m")
        parts = indicator_key.split("_")
        if len(parts) < 2:
            continue  # Format incorrect

        indicator_name = "_".join(parts[:-1])  # ex: "stoch_rsi"
        interval_check = parts[-1]  # ex: "3m"

        # ‚úÖ Si l'intervalle demand√© n'est pas celui en cours, charger l'indicateur correct
        if interval_check != interval:
            latest_indicator = Indicator.objects.filter(symbole=symbole, intervalle=interval_check).order_by("-timestamp").first()

            if not latest_indicator:
                print(f"‚ùå Impossible de r√©cup√©rer l'indicateur '{indicator_name}' sur {interval_check} pour {symbole}.")
                return False  # On arr√™te si on ne trouve pas les donn√©es sur l'autre intervalle

        # R√©cup√©rer la valeur de l'indicateur
        indicator_value = getattr(latest_indicator, indicator_name, None)

        if indicator_value is None:
            print(f"‚ùå L'indicateur '{indicator_name}' n'est pas encore calcul√© sur {interval_check} pour {symbole}.")
            return False  # L'indicateur n'existe pas encore

        # V√©rifier la condition
        op_func, threshold = parse_condition(condition)
        if not op_func or not op_func(indicator_value, threshold):
            print(f"‚ùå Condition √©chou√©e pour {indicator_name} sur {interval_check} ({indicator_value} {condition}) pour {symbole}.")
            return False  # Une condition n'est pas remplie

    return True  # ‚úÖ Toutes les conditions sont remplies

def execute_strategies(symbole):
    """
    V√©rifie toutes les strat√©gies actives et ex√©cute les achats ou ventes si les conditions sont remplies.
    """
    try:
        symbol_strategy = SymbolStrategy.objects.get(symbole=symbole, active=True)
    except SymbolStrategy.DoesNotExist:
        return  # Aucune strat√©gie active pour cette monnaie
    
    strategy = symbol_strategy.strategy
    last_price = symbol_strategy.close_price

    if last_price is None:
        print(f"‚ùå Aucun prix connu pour {symbole}, achat/vente impossible.")
        return

    # ‚úÖ V√©rifier les conditions d'achat
    if not symbol_strategy.entry_price:
        if check_strategy_conditions(symbole, "1m", strategy.buy_conditions):
            entry_price = last_price
            investment_amount = symbol_strategy.investment_amount
            quantity = investment_amount / entry_price  # Quantit√© achet√©e

            # ‚úÖ Enregistrer l'achat
            symbol_strategy.entry_price = entry_price
            symbol_strategy.max_price = entry_price
            symbol_strategy.save()

            # ‚úÖ Ajouter l'achat dans le journal des trades
            TradeLog.objects.create(
                symbole=symbole,
                strategy=strategy,
                entry_price=entry_price,
                investment_amount=investment_amount,
                quantity=quantity
            )

            print(f"‚úÖ Achat simul√© de {quantity:.4f} {symbole} √† {entry_price} USDT (Investissement: {investment_amount} USDT)")
            return  # On ne v√©rifie pas la vente imm√©diatement apr√®s un achat

    # ‚úÖ V√©rifier les conditions de vente
    max_price = max(symbol_strategy.max_price, last_price)
    symbol_strategy.max_price = max_price
    symbol_strategy.save()

    sell_conditions = {
        "sell_1": last_price <= symbol_strategy.entry_price * 0.999,
        "sell_2": last_price >= symbol_strategy.entry_price * 1.01 and (max_price / symbol_strategy.entry_price) * 0.9 >= last_price / symbol_strategy.entry_price
    }

    if any(sell_conditions.values()):
        print(f"üöÄ Vente d√©clench√©e pour {symbole} √† {last_price}")

        # ‚úÖ Fermer le trade et enregistrer la vente
        trade = TradeLog.objects.filter(symbole=symbole, status="open").first()
        if trade:
            trade.close_trade(last_price)

        symbol_strategy.active = False  # D√©sactiver la strat√©gie apr√®s la vente
        symbol_strategy.save()

def get_trade_statistics():
    """
    Renvoie les statistiques globales des trades et par monnaie.
    """
    stats = {}

    # üîπ Global
    stats["total_trades"] = TradeLog.objects.count()
    stats["open_trades"] = TradeLog.objects.filter(status="open").count()
    stats["closed_trades"] = TradeLog.objects.filter(status="closed").count()

    # üîπ Statistiques des gains/pertes
    closed_trades = TradeLog.objects.filter(status="closed")
    stats["win_trades"] = closed_trades.filter(trade_result__gt=0).count()
    stats["lose_trades"] = closed_trades.filter(trade_result__lt=0).count()
    stats["min_gain"] = closed_trades.aggregate(Min("trade_result"))["trade_result__min"]
    stats["max_gain"] = closed_trades.aggregate(Max("trade_result"))["trade_result__max"]
    stats["avg_gain"] = closed_trades.aggregate(Avg("trade_result"))["trade_result__avg"]
    stats["cumulative_gain"] = closed_trades.aggregate(Sum("trade_result"))["trade_result__sum"]

    # üîπ Dur√©e des trades
    stats["min_duration"] = closed_trades.aggregate(Min("duration"))["duration__min"]
    stats["max_duration"] = closed_trades.aggregate(Max("duration"))["duration__max"]
    stats["avg_duration"] = closed_trades.aggregate(Avg("duration"))["duration__avg"]

    # üîπ Statistiques par monnaie
    symbols = TradeLog.objects.values_list("symbole", flat=True).distinct()
    stats["per_symbol"] = {}

    for symbol in symbols:
        trades = TradeLog.objects.filter(symbole=symbol, status="closed")
        stats["per_symbol"][symbol] = {
            "total": trades.count(),
            "win": trades.filter(trade_result__gt=0).count(),
            "lose": trades.filter(trade_result__lt=0).count(),
            "avg_gain": trades.aggregate(Avg("trade_result"))["trade_result__avg"],
            "max_gain": trades.aggregate(Max("trade_result"))["trade_result__max"],
            "min_gain": trades.aggregate(Min("trade_result"))["trade_result__min"],
            "cumulative_gain": trades.aggregate(Sum("trade_result"))["trade_result__sum"],
        }

    return stats